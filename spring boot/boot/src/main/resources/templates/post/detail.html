<!DOCTYPE html>
<html 
	xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" 
	layout:decorate="~{layout/layout.html}">
<head>
<meta charset="UTF-8">
<title>detail</title>
</head>
<body>
	<main layout:fragment="content" class="container">
		<h1>게시글 상세</h1>
		<div class="form-control" th:text=${post.po_title}></div>
		<div class="input-group">
			<div class="form-control" th:text="${post.po_me_id}"></div>
			<div class="form-control" th:text="${post.po_view}"></div>
			<div class="form-control" th:text="${post.po_date}"></div>
		</div>
		<!-- 추천버튼 추가 -->
		<div class="d-flex justify-content-center mt-3">
			<button class="btn btn-outline-primary col-2"
					onclick ="like(event)">추천</button>
		</div>
		<!-- 게시글 내용 -->
		<pre
			class="form-control mt-3" 
			th:text="${post.po_content}"
			style="min-height: 400px"></pre>
		<!-- 게시글 삭제 버튼 -->
		<form  class="mt-1" 
				th:action="@{/post/delete/{num}(num=${post.po_num})}"
				method = "post" onsubmit ="return confirm('게시글을 삭제하겠습니까?');"
				th:if="${#authentication.name == post.po_me_id}">	<!-- 본인글에만 삭제가 보이도록 처리 -->
			<a 
			class="btn btn-outline-warning me-1" 
			th:href="@{/post/update/{num}(num=${post.po_num})}"
			>수정</a>
			<button class="btn btn-outline-danger">삭제</button>
		</form>
		<a 
		th:href="@{/post/list}"
		class="btn btn-outline-success mt-1 w-100">목록이동</a>
		<hr>
		<h1>댓글 목록</h1>
		<!-- 댓글 목록 박스  -->
		<div class="comments-container mt-3">
		
		
			<!-- 댓글이 없는 경우 -->
			<div class="comments-item">
				<div class="comments-wrap form-control mb-3 text-center py-5">
					등록된 댓글이 없습니다.
				</div>
			</div>
			<!-- 댓글 박스 -->
			<div class="comments-item">
				<div class="comments-wrap form-control mb-3">
					<!-- 작성자와 작성일 -->
					<div class="comments-header d-flex justify-content-between mt-3">
						<div>아이디</div>
						<div>2026.01.06 09:47</div>
					</div>

					<!-- 댓글 내용 -->
					<pre class="comments-body">
						댓글 내용입니다.
						엔터가 잘 적용되나요?
					</pre>
					<hr>
					<!-- 수정, 삭제, 대댓글, 버튼 -->
					<div class="comments-footer">
						<button class="btn btn-outline-dark">답글</button>
						<button class="btn btn-outline-warning">수정</button>
						<button class="btn btn-outline-danger">삭제</button>
					</div>
				</div>
			</div>
		</div>
		<!-- 댓글 페이지네이션 박스 -->
		<div class="comments-pagination-container">
			<ul class="pagination justify-content-center">
				<!-- 이전페이지 -->
				<li class="page-item">
					<a href="javascript:void(0);" class="page-link">이전</a>
				</li>
				<!-- 숫자페이지 -->
				<li class="page-item">
					<a href="javascript:void(0);" class="page-link">1</a>
				</li>
				<!-- 다음페이지 -->
				<li class="page-item">
					<a href="javascript:void(0);" class="page-link">다음</a>
				</li>
			</ul>
		</div>
		
		<!-- 댓글 등록 박스 -->
		<hr>
		<div class="comment-input-container">
			<form class="input-group" onsubmit ="insertComment(event)">
				<textarea name ="content" class="form-control"></textarea>
				<button class="btn btn-success">등록</button>
			</form>
		</div>
		
		
		<!-- 댓글 목록 -->
		<script type="text/javascript">
		/*전역변수 : 게시글 번호*/
		
		const postNum = [[${post.po_num}]];
		/*전역변수 : 댓글 페이지*/
		let page = 1;
		
		/*댓글 목록 가져오기*/
		async function getComments(currentPage) {
			//댓글 목록 조회할 때 페이지 정보를 안 넘겨주면
			if(!currentPage){
				// 전역변수로 선언된 page를 가져옴
				currentPage = page;
			}
			try{
				const response = await fetch(`/api/v1/posts/${postNum}/comments?page=${currentPage}`);
				
				if(response.ok){
					const result = await response.json();
					const comments = result.list;
					const pm = result.pm;
					renderComments(comments);
					renderPagination(pm);
				}
			}catch(error){
			console.error(error)
			}
		}
		/* 댓글 페이지네이션 화면에 배치 */
		function renderPagination(pm){
			let pagination = '';
			const container
				= document.querySelector('.comments-pagination-container>.pagination')
			/* 댓글이 없으면 페이지 네이션 없앰 */
			if(pm.endPage == 0){
				container.innerHTML = '';
				return;
			}
			/* 이전 페이지 활성화 */
			if(pm.prev){
				pagination += `
					<li class="page-item" onclick="getComments(page=${pm.startPage - 1})">
					<a href="javascript:void(0);" class="page-link">이전</a>
				</li>
				`;
			}
			
			/* 숫자 페이지 */
			for(i = pm.startPage; i <= pm.endPage; i++){
				
				/* 현재 페이지에 색상 추가*/
				let active = '';
				if(i == pm.cri.page){
					active = 'active';
				}
				//let active = `${i == pm.cri.page ? 'actvie' : ''}`;
				
				pagination += `
					<li class="page-item ${active}" onclick="getComments(page=${i})">
						<a href="javascript:void(0);" class="page-link">${i}</a>
					</li>
				`;
			}
			
			/* 다음 페이지 활성화 */
			
			if(pm.next){
				pagination += `
				<li class="page-item" onclick="getComments(page=${pm.endPage + 1})">
					<a href="javascript:void(0);" class="page-link">다음</a>
				</li>
				`;
			}
			/* 페이지네이션 컨테이너에 페이지네이션을 추가 */
			container.innerHTML = pagination;
		}
		
		/* 댓글 목록 화면에 배치 */
		function renderComments(comments){
			const commentsContainer
				= document.querySelector(".comments-container")
				
				let commentsItems ='';
			
			/*댓글이 없는 경우*/
			if(comments.length == 0){
				commentsItems = 
					`
					<div class="comments-item">
						<div class="comments-wrap form-control mb-3 text-center py-5">
							등록된 댓글이 없습니다.
						</div>
					</div>
					`;
				commentsContainer.innerHTML = commentsItems;
				return;
			}
			
			/* 댓글이 있는 경우 */
			//자바에서 향상된 for문과 같은 역할
			for(comment of comments){
				
				let replyBtn = '';
				let ps = '';

				/* 댓글인 경우 : 대댓글이 보여야함*/
				if(comment.oriNum == comment.num){
					replyBtn = `
						<button class="btn btn-outline-dark" 
								onclick="changeReplyBox(this, ${comment.num})">답글</button>

					`;
				}
				/* 대댓인 경우 : 대댓글이 안보이고, 왼쪽 여백을 추가*/
		
				else{
					ps = 'ps-5'
				
				}
				
				/* 댓글이 삭제된 경우 */
				if(comment.del == 'Y'){
					commentsItems += `
						<div class="comments-item ${ps}">
							<div class="comments-wrap form-control mb-3">
								삭제된 댓글입니다.
							</div>
						</div>
					`;
					commentsContainer.innerHTML = commentsItems;
					continue;
				}
				
				let udBtns ='';
				/* 작성자인 경우 수정 삭제 버튼을 추가 */
				if(comment.id == '[[${#authentication.name}]]'){
					udBtns = `
						<button class="btn btn-outline-warning"
								onclick="changeUpdateBox(this, ${comment.num})">수정</button>
						<button class="btn btn-outline-danger"
								onclick="deleteComments(${comment.num})">삭제</button>
					`
				}
				
				commentsItems +=
				`			
				<div class="comments-item ${ps}">
					<div class="comments-wrap form-control mb-3">
						<!-- 작성자와 작성일 -->
						<div class="comments-header d-flex justify-content-between mt-3">
							<div>${comment.id}</div>
							<div>${comment.date}</div>
						</div>
						<hr>
						<!-- 댓글 내용 -->
						<pre class="comments-body">${comment.content}</pre>
						<!-- 수정,삭제,대댓글 버튼 -->
						<div class="comments-footer">
							<hr>
							${replyBtn}
							${udBtns}
						</div>
					</div>
				</div>
				`;

			}

			commentsContainer.innerHTML = commentsItems;
		}
		
		/*댓글 목록 호출*/
		getComments();

		</script>
		
		<!-- 댓글 등록 -->
		<script type="text/javascript">
			/* 댓글을 등록하는 함수
			event : 발생한 이벤트 정보
			el : 이벤트가 발생한 요소(form 태그)
			oriNum : 참조하는 댓글 번호 
			*/
			async function insertComment(event, el, oriNum){
				/* form태그 기본 이벤트를 막음*/
				event.preventDefault();

				
				/* textarea 요소 선택*/
				//El = Element 줄인거
				const textareaEl = document.querySelector("[name=content]");
				
				/* textarea에서 value값을 가져옴*/
				const content = textareaEl.value;
				
				/* 참조 댓글번호가 없으면 0으로 설정*/
				if(!oriNum){
					oriNum = 0;
				}
				
				// 가져온 댓글을 객체로 변환
				let obj = {
						content,
						oriNum
				};
			
				try{
					/* 비동기 통신으로 댓글을 서버에 전송*/
					const response = await fetch(`/api/v1/posts/${postNum}/comments`, {
						method : 'post',
						headers : {
							'Content-Type' : 'application/json'
						},
						//댓글 내용이 있는 객체를 JSON 문자열로 변환
						body : JSON.stringify(obj)
					});
					
					if(response.ok){
						//서버에서 보낸 결과를 가져옴
						const result = await response.text(); //문자열로 보낼꺼라 text
						//댓글 입력창을 비움
						textareaEl.value = '';
						//댓글 목록 새로고침
						getComments(1);
						alert(result);			
					}
				}catch(error){
					console.orror(error);
				}
			}
			

			// 댓글삭제
			async function deleteComments(num){
		
				  try {
				    const response = await fetch(`/api/v1/posts/${postNum}/comments/${num}`, {
				      method: 'delete',
				      headers: {
				    	  //'Content-Type' : ''
				      },
				      
				      //body: JSON.stringify(postData)
				    })
				    if(response.ok){
				    	const result = await response.text();
				    	alert(result);
				    	getComments();
				    }
				  }catch(error){
						console.error(error);		  
				  }
			}
			
		</script>
		
		<!-- 대댓글 등록 -->
		<script type="text/javascript">
		/*대댓글을 클릭하면 대댓글 입력창이 나오게 하는 함수*/
		/*대댓은 화면배치고 통신은 댓글이 하기 때문에 async 안해도 됨 */
		function changeReplyBox(el, oriNum){
			//대댓글 입력창을 HTML코드로 구성
			let inputEl = `
				<div class="comment-input-container">
					<form class="input-group" onsubmit ="insertComment(event, this, ${oriNum})">
						<textarea name ="content" class="form-control"></textarea>
						<button class="btn btn-success">등록</button>
					</form>
				</div>
			`;
			//원하는 위치에 HTML코드를 배치
			//.comments-footer 다음에 대댓글 입력창을 배치
			el.parentElement.insertAdjacentHTML('afterend', inputEl);

		}

		</script>
		
		<!-- 추천 -->
		<script type="text/javascript">
		async function like(){
			/*
			비동기 통신으로 서버에 추천을 요청
			URL : /api/v2/posts/게시글번호/like
			method : post
			서버에서 보낸 문자열을 alert으로 출력
			*/	
			try {
			     const response = await fetch(`/api/v2/posts/${postNum}/like`, {
			    	 
			      	method: 'post', /*method의 종류 : get | post | put | patch | delete*/
			     	headers: {
			    		  // 'Content-Type' : 'application/json'
			      	},
			     // body: JSON.stringify(obj)
			    });
			    if(response.ok){
			    	 const result = await response.text();
			    	 alert(result);
			    }
			}catch(error){
					console.error(error);		  
			}
		}
		
		</script>
		
		
		<!-- 댓글 수정 -->
		<script type="text/javascript">

		function changeUpdateBox(el, coNum){
			//기존 댓글 내용을 가져옴
			const contentEl = el.closest(".comments-wrap").querySelector(".comments-body");
			let content = contentEl.textContent;
			let inputEl = `
				<div class="comment-update-container">
																<!-- event,form태그(submit이 발생된 요소),댓글번호 -->
					<form class="input-group" onsubmit ="updateComment(event, this, ${coNum})"> 
						<textarea name ="content" class="form-control">${content}</textarea>
						<button class="btn btn-success">수정</button>
					</form>
				</div>
			`;
			
			/*el.parentElement.insertAdjacentHTML('afterend', inputEl); 나눠쓰면 아래처럼됨*/
			const parent = el.parentElement; //버튼들이 있는 박스 변수선언해서 묶어주기
			//수정 버튼 다음에 수정창을 추가
			parent.insertAdjacentHTML('afterend', inputEl);
			
			//수정 버튼 클릭시 버튼들을 감춤 (위에서 선언한 parent 변수를 통해)
			parent.classList.add('d-none');
			
			//기존 댓글창을 감춤
			contentEl.classList.add('d-none');
			

		}
		
		async function updateComment(e, el, coNum){
			//form태그의 submit을 막음(서버로 전송하는걸 막음)
			e.preventDefault();
			
			//수정된 댓글 내용을 가져와야 함
			//1. 댓글 내용이 입력된 요소를 선택(textarea)
			const inputEl = el.querySelector("[name=content]");
			
			//2. 요소에서 내용을 가져옴(value)
			const content = inputEl.value;
			
			let obj = {
					content				
			};
			
			try {
			     const response = await fetch(`/api/v1/posts/${postNum}/comments/${coNum}`, {
			    	 
			      	method: 'put', /*method의 종류 : get | post | put | patch | delete*/
			     	headers: {
			    		  'Content-Type' : 'application/json'
			      	},
			      //body : '{"content" : "' + content'"}', 
			      //body를 위에처럼 obj객체로 만들지않고 JSON 문자열로 직접 작성하면 이렇게도 가능하지만, 유지보수와 안정성 때문에 비추천
			      body: JSON.stringify(obj)
			    });
			    if(response.ok){
			    	 const result = await response.text();
			    	 alert(result);
			    	 getComments();
			    }
			}catch(error){
					console.error(error);		  
			}

		}			
		</script>
	</main>
</body>
</html>